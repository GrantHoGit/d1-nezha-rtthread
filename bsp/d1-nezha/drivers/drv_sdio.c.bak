/*
 * Copyright (c) 2006-2018, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2018-02-08     RT-Thread    the first version
 */
#include <rtthread.h>
#include <rthw.h>
#include <rtdevice.h>
#include <string.h>

#include "drv_sdio.h"
#include "interrupt.h"
#include "mmu.h"
#include "drv_gpio.h"
#include "drv_clock.h"

extern void rt_hw_cpu_dcache_invalidate(void *addr, int size);
extern void rt_hw_cpu_dcache_clean(void *addr, int size);

#define DBG_ENABLE
#define DBG_SECTION_NAME  "[MMC]"
/*
 * The possible values of 'DBG_LEVEL' are:
 * DBG_LOG, DBG_INFO, DBG_WARNING, DBG_ERROR
 */
#define DBG_LEVEL DBG_WARNING
#define DBG_COLOR
#include <rtdbg.h>

#if defined(BSP_USING_SDIO0) || defined(BSP_USING_SDIO2)

#define CONFIG_MMC_USE_DMA
#define DMA_ALIGN       (32)

struct mmc_xfe_des
{
    rt_uint32_t size;    /* block size */
    rt_uint32_t num;     /* block num */
    rt_uint8_t *buff;    /* buff addr */
    rt_uint32_t flag;    /* write or read or stream */
#define MMC_DATA_WRITE  (1 << 0)
#define MMC_DATA_READ   (1 << 1)
#define MMC_DATA_STREAM (1 << 2)
};

struct mmc_flag
{
    volatile rt_uint32_t risr;
    volatile rt_uint32_t idst;
};

struct sdio_drv
{
    struct rt_mmcsd_host *host;
    struct rt_mmcsd_req  *req;
    struct rt_semaphore rt_sem;
    struct mmc_xfe_des xfe;
    struct mmc_flag flag;
    v3s_mmc_t mmc_des;
    rt_uint8_t *mmc_buf;
    rt_uint8_t usedma;
};

#ifdef CONFIG_MMC_USE_DMA
#ifdef BSP_USING_SDIO0
ALIGN(DMA_ALIGN) static rt_uint8_t dma_buffer0[64 * 1024];
#endif
#ifdef BSP_USING_SDIO2
ALIGN(DMA_ALIGN) static rt_uint8_t dma_buffer2[64 * 1024];
#endif
#endif

static void mmc_request_end(struct rt_mmcsd_host *host, struct rt_mmcsd_req *req);

static void mmc_delay_us(int us)
{
    volatile rt_uint32_t temp;

    while (us--)
    {
        temp = 0x800;  /* CPU clock is 1024MHZ */
        while (temp--)
        {
            temp = temp;
        }
    }
}

static void mmc_dump_errinfo(rt_uint32_t err)
{
    dbg_log(DBG_ERROR, "[err]:0x%08x, %s%s%s%s%s%s%s%s%s%s%s\n",
            err,
            err & SDXC_RespErr     ? " ResponseError"       : "",
            err & SDXC_RespCRCErr  ? " ResponseCRCError"    : "",
            err & SDXC_DataCRCErr  ? " DataCRCError"        : "",
            err & SDXC_RespTimeout ? " ResponseTimeOut"     : "",
            err & SDXC_DataTimeout ? " DataTimeOut"         : "",
            err & SDXC_DataStarve  ? " DataStarvation"      : "",
            err & SDXC_FIFORunErr  ? " FIFORunError"        : "",
            err & SDXC_HardWLocked ? " HardWLocked"         : "",
            err & SDXC_StartBitErr ? " StartBitError"       : "",
            err & SDXC_EndBitErr   ? " EndBitError"         : "",
            err == 0  ? " STO"    : ""
           );
}

/* send the 'Change Clock' command */
static int mmc_update_clk(v3s_mmc_t mmc)
{
    rt_uint32_t cmd;
    rt_uint32_t timeout = 2000000;

    /* cmd load */
    cmd = SDXC_LOAD_CMD | SDXC_UPDATE_CLOCK_CMD | SDXC_WAIT_OVER_CMD;
    mmc->cmdr_reg = cmd;
    /* while load success */
    while ((mmc->cmdr_reg & SDXC_LOAD_CMD) && (--timeout))
    {
        mmc_delay_us(1);
    }
    if (!timeout)
    {
        dbg_log(DBG_ERROR, "mmc update clk failed\n");
        return -RT_ERROR;
    }

    /* clean interrupt */
    mmc->risr_reg = mmc->risr_reg;

    return RT_EOK;
}

/* MMC DMA description array */
ALIGN(DMA_ALIGN) static struct mmc_des_v4p1 pdes[128];  // must ALIGN(32)

static rt_err_t mmc_trans_data_by_dma(v3s_mmc_t mmc, struct mmc_xfe_des *xfe)
{
    rt_uint32_t rval;
    rt_uint32_t des_idx;
    rt_uint32_t length = xfe->size * xfe->num;

    /* flush the cache of the memory to transfer */
    rt_hw_cpu_dcache_clean(xfe->buff, length);
    asm volatile ("dsb");

    /* prepare the descriptor list, split the data if too long */
    des_idx = 0;
    while (length > 0 && des_idx < 128)
    {
        pdes[des_idx].own = 1;
        pdes[des_idx].card_err_sum = 0;
        pdes[des_idx].des_chain = 1;
        pdes[des_idx].first_des = 0;
        pdes[des_idx].buf_addr_ptr = (rt_uint32_t)(xfe->buff) + des_idx * SDXC_DES_BUFFER_MAX_LEN;

        if (length > SDXC_DES_BUFFER_MAX_LEN)
        {
            pdes[des_idx].dic = 1;      /* disable interrupt on completion */
            pdes[des_idx].last_des = 0; /* not the last description */

            pdes[des_idx].data_buf_sz = SDXC_DES_BUFFER_MAX_LEN;
            pdes[des_idx].next_des_ptr = (rt_uint32_t) &pdes[des_idx + 1];
            length -= SDXC_DES_BUFFER_MAX_LEN;
        }
        else
        {
            pdes[des_idx].dic = 0;      /* enable interrupt on completion */
            pdes[des_idx].last_des = 1; /* the last description */
            pdes[des_idx].data_buf_sz = length;
            pdes[des_idx].next_des_ptr = 0;
            length = 0;
        }
        des_idx++;
    }
    pdes[0].first_des = 1;

    /* also flush the cache of the descriptions */
    rt_hw_cpu_dcache_clean(pdes, sizeof(struct mmc_des_v4p1) * (des_idx));
    asm volatile ("dsb");

    /*
     * GCTRLREG
     * GCTRL[2] : DMA reset
     * GCTRL[5] : DMA enable
     *
     * IDMACREG
     * IDMAC[0] : IDMA soft reset
     * IDMAC[1] : IDMA fix burst flag
     * IDMAC[7] : IDMA enable
     *
     * IDIECREG
     * IDIE[0]  : IDMA transmit interrupt flag
     * IDIE[1]  : IDMA receive interrupt flag
     */
    rval = mmc->gctl_reg;
    mmc->gctl_reg = rval | (1 << 5) | (1 << 2); /* enable and reset dma */
    while(mmc->gctl_reg & (1<<2));

    mmc->dmac_reg = (1 << 0);                   /* idma reset */
    while(mmc->dmac_reg & 0x1) ;                /* wait idma reset done */
    mmc->dmac_reg = (1 << 1) | (1 << 7);        /* enable idma and set fixed burst */

    /* enable the tx or rx interrupt for idma */
    rval = mmc->idie_reg & (~3);
    if (xfe->flag == MMC_DATA_WRITE)
        rval |= (1 << 0);   /* Tx interrupt enable */
    else
        rval |= (1 << 1);   /* Rx interrupt enable */
    mmc->idie_reg = rval;

    //mmc->fwlr_reg = (2U << 28) | (7U << 16) | 8;
    mmc->fwlr_reg = (8 << 28) | (15 << 16) | 16;
    mmc->dlba_reg = (rt_uint32_t) pdes;     /* install the descriptor list */

    return RT_EOK;
}

static rt_err_t mmc_trans_data_by_cpu(v3s_mmc_t mmc, struct mmc_xfe_des *xfe)
{
    rt_uint32_t i;
    rt_uint32_t byte_cnt = xfe->size * xfe->num;
    rt_uint32_t *buff = (rt_uint32_t *)(xfe->buff);
    volatile rt_uint32_t timeout = 2000000;

    if (xfe->flag == MMC_DATA_WRITE)
    {
        for (i = 0; i < (byte_cnt >> 2); i++)
        {
            while(--timeout && (mmc->star_reg & (1 << 3))); /* until FIFO is not full*/

            if (timeout <= 0)
            {
                dbg_log(DBG_ERROR, "write data by cpu failed status:0x%08x\n", mmc->star_reg);
                return -RT_ERROR;
            }
            mmc->fifo_reg = buff[i];
            timeout = 2000000;
        }
    }
    else
    {
        for (i = 0; i < (byte_cnt >> 2); i++)
        {
            while(--timeout && (mmc->star_reg & (1 << 2))); /* until FIFO is not empty */

            if (timeout <= 0)
            {
                dbg_log(DBG_ERROR, "read data by cpu failed status:0x%08x\n", mmc->star_reg);
                return -RT_ERROR;
            }
            buff[i] = mmc->fifo_reg;
            timeout = 2000000;
        }
    }

    return RT_EOK;
}

/* set up the sdmmc clock and update it */
static rt_err_t mmc_config_clock(v3s_mmc_t mmc, int clk)
{
    rt_uint32_t rval = 0;

    /* disable card clock */
    rval = mmc->ckcr_reg;
    rval &= ~(1 << 16);
    mmc->ckcr_reg = rval;

    if (mmc_update_clk(mmc) != RT_EOK)
    {
        dbg_log(DBG_ERROR, "clk update fail line:%d\n", __LINE__);
        return -RT_ERROR;
    }

    if (mmc == MMC0)
    {
        mmc_set_clk(SDMMC0, clk);
    }
    else
    {
        mmc_set_clk(SDMMC2, clk);
    }

    /* Re-enable card clock */
    rval = mmc->ckcr_reg;
    rval |=  (0x1 << 16); //(3 << 16);
    mmc->ckcr_reg = rval;

    if(mmc_update_clk(mmc) != RT_EOK)
    {
        dbg_log(DBG_ERROR, "clk update fail line:%d\n", __LINE__);
        return -RT_ERROR;
    }

    return RT_EOK;
}

static int mmc_core_init(v3s_mmc_t mmc)
{
    /* Reset controller */
    mmc->gctl_reg = 0x7; /*0x40000007*/
    while (mmc->gctl_reg & 0x7);
    /* release eMMC reset signal */
    mmc->hwrst_reg = 1;
    mmc->hwrst_reg = 0;
    rt_thread_delay(1);
    mmc->hwrst_reg = 1;
    rt_thread_delay(1);
#define  SMC_DATA_TIMEOUT     0xffffffU
#define  SMC_RESP_TIMEOUT     0xff
    mmc->tmor_reg = (SMC_DATA_TIMEOUT << 8) | SMC_RESP_TIMEOUT; //Set Data & Response Timeout Value

    mmc->thldc_reg = (512 << 16) | (1U << 0);

    return 0;
}

/* set up the sdmmc clock and the buswidth */
static rt_err_t mmc_set_clock_buswidth(v3s_mmc_t mmc, int clk, int bus_width)
{
    dbg_log(DBG_LOG, "mmc set io bus width:%d clock:%d\n",
            (bus_width == MMCSD_BUS_WIDTH_8 ? 8 :
             (bus_width == MMCSD_BUS_WIDTH_4 ? 4 : 1)),
            clk);

    /* change clock */
    if (clk && (mmc_config_clock(mmc, clk) != RT_EOK))
    {
        dbg_log(DBG_ERROR, "update clock failed\n");
        return -RT_ERROR;
    }

    /* Change bus width */
    if (bus_width == MMCSD_BUS_WIDTH_8)
    {
        mmc->bwdr_reg = 2;
    }
    else if (bus_width == MMCSD_BUS_WIDTH_4)
    {
        mmc->bwdr_reg = 1;
    }
    else
    {
        mmc->bwdr_reg = 0;
    }

    return RT_EOK;
}

static int mmc_send_cmd(struct rt_mmcsd_host *host, struct rt_mmcsd_cmd *cmd)
{
    unsigned int cmdval  = 0x80000000;
    signed int timeout   = 0;
    int err              = 0;
    unsigned int status  = 0;
    struct rt_mmcsd_data *data = cmd->data;
    unsigned int bytecnt = 0;
    struct sdio_drv *sdio_des = (struct sdio_drv *)host->private_data;
    v3s_mmc_t mmc = sdio_des->mmc_des;

    timeout = 5000 * 1000;
    status = mmc->star_reg;
    while (status & (1 << 9))   /* wait until card data busy is reset */
    {
        dbg_log(DBG_LOG, "note: check card busy\n");

        status = mmc->star_reg;
        if (!timeout--)
        {
            err = -1;
            dbg_log(DBG_ERROR, "mmc cmd12 busy timeout data:0x%08x\n", status);
            return err;
        }
        mmc_delay_us(1);
    }
    /*
     * CMDREG
     * CMD[5:0] : Command index
     * CMD[6]   : Has response
     * CMD[7]   : Long response
     * CMD[8]   : Check response CRC
     * CMD[9]   : Has data
     * CMD[10]  : Write
     * CMD[11]  : Steam mode
     * CMD[12]  : Auto stop
     * CMD[13]  : Wait previous over
     * CMD[14]  : About cmd
     * CMD[15]  : Send initialization
     * CMD[21]  : Update clock
     * CMD[31]  : Load cmd
     */
    if (!cmd->cmd_code)
        cmdval |= (1 << 15);    /* if no code, send initialization command */
    if (resp_type(cmd) != RESP_NONE)
        cmdval |= (1 << 6);     /* no response */
    if (resp_type(cmd) == RESP_R2)
        cmdval |= (1 << 7);     /* long response for R2 */
    if ((resp_type(cmd) != RESP_R3) && (resp_type(cmd) != RESP_R4))
        cmdval |= (1 << 8);     /* enable CRC check for response */

    if (data)
    {
        cmdval |= (1 << 9) | (1 << 13);     /* transfer data and wait for its completion */
        if (data->flags & DATA_DIR_WRITE)
            cmdval |= (1 << 10);            /* direction */
        if (data->blks > 1)
            cmdval |= (1 << 12);            /* send stop CMD automatically */
        mmc->bksr_reg = data->blksize;
        bytecnt = data->blksize * data->blks;
        mmc->bycr_reg = bytecnt;
    }

    dbg_log(DBG_LOG, "cmd %d(0x%08x), arg 0x%08x\n", cmd->cmd_code, cmdval | cmd->cmd_code, cmd->arg);
    mmc->cagr_reg = cmd->arg;
    if (!data)
    {
        mmc->cmdr_reg = cmdval | cmd->cmd_code;
        mmc->imkr_reg |= 0x1 << 2;          /* enable command complete interrupt */
    }

    /*
     * transfer data and check status
     * STATREG[2] : FIFO empty
     * STATREG[3] : FIFO full
     */
    if (data)
    {
        dbg_log(DBG_LOG, "mmc trans data %d bytes addr:0x%08x\n", bytecnt, data);
#ifdef CONFIG_MMC_USE_DMA
        if (bytecnt > 64)
        {
            sdio_des->usedma = 1;
            mmc->gctl_reg = mmc->gctl_reg & (~(1<<31)); /* FIFO mode: DMA bus */
            mmc_trans_data_by_dma(mmc, &sdio_des->xfe);
            mmc->cmdr_reg = cmdval | cmd->cmd_code;
        }
        else
#endif
        {
            sdio_des->usedma = 0;
            mmc->gctl_reg = mmc->gctl_reg | (1<<31);    /* FIFO mode: AHB bus */
            mmc->cmdr_reg = cmdval | cmd->cmd_code;
            mmc_trans_data_by_cpu(mmc, &sdio_des->xfe);
        }

        if (data->blks > 1)
        {
            mmc->imkr_reg |= (0x1 << 14);   /* enable auto-stop-command-done interrupt */
        }
        else
        {
            mmc->imkr_reg |= (0x1 << 3);    /* enable data-transfer-complete interrupt */
        }
    }

    mmc->imkr_reg |= 0xbfc2;

    if (data)
    {
        //TODO:2 * bytecnt * 4?
        timeout = sdio_des->usedma ? (2 * bytecnt * 4) : 100; //0.04us(25M)*2(4bit width)*25()
        if (timeout < 10)
        {
            timeout = 10;
        }
    }
    else
    {
        timeout = 200;
    }

    /* wait the interrupt to release the semaphore */
    if (rt_sem_take(&sdio_des->rt_sem, timeout) != RT_EOK)
    {
        dbg_log(DBG_ERROR, "Taking sdio_des->rt_sem failed!\n");
        err = (mmc->risr_reg | sdio_des->flag.risr) & 0xbfc2;
        goto out;
    }

    err = (mmc->risr_reg | sdio_des->flag.risr) & 0xbfc2;
    if (err)
    {
        cmd->err = -RT_ETIMEOUT;
        goto out;
    }

    if (resp_type(cmd) == RESP_R2)
    {
        cmd->resp[3] = mmc->resp0_reg;
        cmd->resp[2] = mmc->resp1_reg;
        cmd->resp[1] = mmc->resp2_reg;
        cmd->resp[0] = mmc->resp3_reg;
        dbg_log(DBG_LOG, "mmc resp 0x%08x 0x%08x 0x%08x 0x%08x\n",
                cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
    }
    else
    {
        cmd->resp[0] = mmc->resp0_reg;
        dbg_log(DBG_LOG, "mmc resp 0x%08x\n", cmd->resp[0]);
    }

out:
    if (err)
    {
        mmc_dump_errinfo(err & 0xbfc2);
    }
    if (data && sdio_des->usedma)
    {
        /* IDMASTAREG
         * IDST[0] : idma tx int
         * IDST[1] : idma rx int
         * IDST[2] : idma fatal bus error
         * IDST[4] : idma descriptor invalid
         * IDST[5] : idma error summary
         * IDST[8] : idma normal interrupt sumary
         * IDST[9] : idma abnormal interrupt sumary
         */
        status = mmc->idst_reg;
        mmc->idst_reg = status;
        mmc->idie_reg = 0;
        mmc->dmac_reg = 0;
        mmc->gctl_reg = mmc->gctl_reg & (~(1 << 5));
    }
    if (err)
    {
        if (data && (data->flags & DATA_DIR_READ) && (bytecnt == 512))
        {
            mmc->gctl_reg = mmc->gctl_reg | 0x80000000;

            timeout = 1000;
            dbg_log(DBG_LOG, "Read remain data\n");
            while((mmc->star_reg & (1 << 2)) == 0) /* until FIFO is empty */
            {
                rt_uint32_t tmp = mmc->fifo_reg;
                tmp = tmp;
                dbg_log(DBG_LOG, "Read data 0x%08x\n", tmp);
                mmc_delay_us(1);
                if (!(timeout--))
                {
                    dbg_log(DBG_ERROR, "Read remain data timeout\n");
                    break;
                }
            }
        }

        mmc->gctl_reg = 0x7;    /* reset DMA, FIFO and SDC */
        while (mmc->gctl_reg & 0x7) { };

        mmc_update_clk(mmc);
        cmd->err = -RT_ETIMEOUT;
        dbg_log(DBG_ERROR, "mmc cmd %d err\n", cmd->cmd_code);
    }

    mmc->gctl_reg &= ~(0x1 << 4);
    mmc->imkr_reg &= ~0xffff;
    mmc->risr_reg = 0xffffffff;
    mmc->gctl_reg |= 0x1 << 4;
    while (!rt_sem_take(&sdio_des->rt_sem, 0)) {}
    mmc_request_end(sdio_des->host, sdio_des->req);

    return err;
}

static void mmc_request_end(struct rt_mmcsd_host *host, struct rt_mmcsd_req *req)
{
    struct rt_mmcsd_data *data;
    unsigned byte_cnt;
    struct sdio_drv *sdio = (struct sdio_drv *)host->private_data;

#ifdef CONFIG_MMC_USE_DMA
    data = req->cmd->data;
    if (data)
    {
        byte_cnt = data->blksize * data->blks;
        if ((byte_cnt > 64) && (data->flags & DATA_DIR_READ))
        {
            rt_hw_cpu_dcache_invalidate(sdio->xfe.buff, byte_cnt);
            asm volatile ("dsb");

            if (((rt_uint32_t)data->buf) & (DMA_ALIGN - 1))
            {
                memcpy(data->buf, sdio->xfe.buff, byte_cnt);
            }
        }
    }
#endif
    mmcsd_req_complete(host);
}

/* driver interfaces */
static void sdio_request_send(struct rt_mmcsd_host *host, struct rt_mmcsd_req *req)
{
    struct rt_mmcsd_data *data;
    int byte_cnt;
    struct sdio_drv *sdio;

    sdio = (struct sdio_drv *)host->private_data;
    sdio->req = req;
    data = req->cmd->data;

    if (data)
    {
        sdio->xfe.size = data->blksize;
        sdio->xfe.num  = data->blks;
        sdio->xfe.buff = (rt_uint8_t *)data->buf;
        sdio->xfe.flag = (data->flags & DATA_DIR_WRITE) ? \
                         MMC_DATA_WRITE : MMC_DATA_READ;
#ifdef CONFIG_MMC_USE_DMA
        byte_cnt = data->blksize * data->blks;
        if ((byte_cnt > 64) && (((rt_uint32_t)data->buf) & (DMA_ALIGN - 1)))
        {
            sdio->xfe.buff = (rt_uint8_t *)sdio->mmc_buf;
            if (data->flags & DATA_DIR_WRITE)
            {
                memcpy(sdio->mmc_buf, data->buf, byte_cnt);
                rt_hw_cpu_dcache_clean(sdio->mmc_buf, byte_cnt);
                asm volatile ("dsb");
            }
        }
#endif
    }

    memset(&sdio->flag, 0, sizeof(struct mmc_flag));
    mmc_send_cmd(host, req->cmd);

    return;
}

static void sdio_set_iocfg(struct rt_mmcsd_host *host, struct rt_mmcsd_io_cfg *io_cfg)
{
    int clk = io_cfg->clock;
    int width = io_cfg->bus_width;
    struct sdio_drv *sdio_des = (struct sdio_drv *)host->private_data;
    v3s_mmc_t mmc = sdio_des->mmc_des;

    mmc_set_clock_buswidth(mmc, clk, width);
}

static const struct rt_mmcsd_host_ops ops =
{
    sdio_request_send,
    sdio_set_iocfg,
    RT_NULL,
    RT_NULL,
};

static void sdio_interrupt_handle(int irqno, void *param)
{
    rt_uint32_t risr, idst;
    rt_uint32_t status;
    struct sdio_drv *sdio_des = (struct sdio_drv *)param;
    struct rt_mmcsd_data *data = sdio_des->req->cmd->data;
    v3s_mmc_t mmc = sdio_des->mmc_des;

    risr = mmc->risr_reg;
    idst = mmc->idst_reg;

    mmc->risr_reg = risr & mmc->imkr_reg;
    mmc->idst_reg = idst & mmc->idie_reg;

    sdio_des->flag.risr |= risr;
    sdio_des->flag.idst |= idst;

    if (data)
    {
        int done = 0;

        status = sdio_des->flag.risr | mmc->risr_reg;
        if (data->blks > 1)     /* not wait auto stop when MMC_CMD_MANUAL is set */
        {
            if (sdio_des->usedma)
                done = ((status & (1 << 14)) && (sdio_des->flag.idst & 0x3)) ? 1 : 0;
            else
                done = status & (1 << 14);
        }
        else
        {
            if (sdio_des->usedma)
                done = ((status & (1 << 3)) && (sdio_des->flag.idst & 0x3)) ? 1 : 0;
            else
                done = status & (1 << 3);
        }

        if (done)
        {
            rt_sem_release(&sdio_des->rt_sem);
        }
    }
    else
    {
        rt_sem_release(&sdio_des->rt_sem);
    }
}

/* set up the sdio pins */
static void sdio_setup_gpio(struct sdio_drv *sdio_des)
{
    int pin;

#ifdef BSP_USING_SDIO0
    if ((rt_uint32_t)sdio_des->mmc_des == MMC0_BASE_ADDR)
    {
        /* SDC0: PF1-PF3 */
        for (pin = GPIO_PIN_1; pin <= GPIO_PIN_3; pin++)
        {
            gpio_set_func(GPIO_PORT_F, pin, IO_FUN_2);
            gpio_set_pull_mode(GPIO_PORT_F, pin, PULL_UP);
            gpio_set_drive_level(GPIO_PORT_F, pin, DRV_LEVEL_2);
        }
    }
#endif
#ifdef BSP_USING_SDIO2
    if ((rt_uint32_t)sdio_des->mmc_des == MMC2_BASE_ADDR)
    {
        /* SDC2: PC0-PC3: PC2(RST) */
        for (pin = GPIO_PIN_0; pin <= GPIO_PIN_3; pin++)
        {
            gpio_set_func(GPIO_PORT_C, pin, IO_FUN_2);
            gpio_set_pull_mode(GPIO_PORT_C, pin, PULL_UP);
            gpio_set_drive_level(GPIO_PORT_C, pin, DRV_LEVEL_2);
        }
    }
#endif
}

static void sdio_enable_clock(struct sdio_drv *sdio_des)
{
#ifdef BSP_USING_SDIO0
    if ((rt_uint32_t)sdio_des->mmc_des == MMC0_BASE_ADDR)
    {
        mmc_set_clk(SDMMC0, 24000000);
        bus_gate_clk_enable(SDMMC0_GATING);
        bus_software_reset_enable(SDMMC0_RESET);
        bus_software_reset_disable(SDMMC0_RESET);
    }
#endif
#ifdef BSP_USING_SDIO2
    if ((rt_uint32_t)sdio_des->mmc_des == MMC2_BASE_ADDR)
    {
        mmc_set_clk(SDMMC2, 24000000);
        bus_gate_clk_enable(SDMMC2_GATING);
        bus_software_reset_enable(SDMMC2_RESET);
        bus_software_reset_disable(SDMMC2_RESET);
    }
#endif
}

static void sdio_irq_init(void *param)
{
    struct sdio_drv *sdio_des = (struct sdio_drv *)param;

#ifdef BSP_USING_SDIO0
    if ((rt_uint32_t)sdio_des->mmc_des == MMC0_BASE_ADDR)
    {
        rt_hw_interrupt_install(V3S_INTERRUPT_SDMMC0, sdio_interrupt_handle, param, "mmc0_irq");
        rt_hw_interrupt_umask(V3S_INTERRUPT_SDMMC0);
    }
#endif
#ifdef BSP_USING_SDIO2
    if ((rt_uint32_t)sdio_des->mmc_des == MMC2_BASE_ADDR)
    {
        rt_hw_interrupt_install(V3S_INTERRUPT_SDMMC2, sdio_interrupt_handle, param, "mmc2_irq");
        rt_hw_interrupt_umask(V3S_INTERRUPT_SDMMC2);
    }
#endif

    /* enable the device to generate interrupts */
    sdio_des->mmc_des->gctl_reg |= (0x1 << 4);
}

#ifdef BSP_USING_SDIO0
static struct sdio_drv sdio_drv0 = {0};
#endif
#ifdef BSP_USING_SDIO2
static struct sdio_drv sdio_drv2 = {0};
#endif

static int sdio_device_init(struct sdio_drv *sdio_drv, rt_uint32_t addr, void *dma_buffer)
{
    struct rt_mmcsd_host *host;
    host = mmcsd_alloc_host();
    if (!host)
    {
        dbg_log(DBG_ERROR, "alloc host failed\n");
        goto err;
    }

    if (rt_sem_init(&sdio_drv->rt_sem, "sdio_sem", RT_NULL, RT_IPC_FLAG_FIFO))
    {
        dbg_log(DBG_ERROR, "sem init failed\n");
        goto err;
    }
    sdio_drv->mmc_des = (v3s_mmc_t) addr;
#ifdef CONFIG_MMC_USE_DMA
    sdio_drv->mmc_buf = dma_buffer;
#endif
    /* initialize mmc pins */
    sdio_setup_gpio(sdio_drv);
    /* set up the clock */
    sdio_enable_clock(sdio_drv);
    /* enable interrupts */
    sdio_irq_init(sdio_drv);

    host->ops = &ops;
    host->freq_min = 400 * 1000;
    host->freq_max = 50 * 1000 * 1000;
    host->valid_ocr = VDD_26_27 | VDD_27_28 | VDD_28_29 | VDD_29_30 | VDD_30_31 | VDD_31_32 |
                      VDD_32_33 | VDD_33_34 | VDD_34_35 | VDD_35_36;
    host->flags = MMCSD_MUTBLKWRITE | MMCSD_SUP_SDIO_IRQ | MMCSD_SUP_HIGHSPEED;
    //host->max_seg_size = 2048;
    host->max_seg_size = 32*1024;
    //host->max_dma_segs = 10;
    host->max_dma_segs = 1;
    host->max_blk_size = 512;
    host->max_blk_count = 4096;

    host->private_data = sdio_drv;

    sdio_drv->host = host;

    return RT_EOK;
err:
    if (host)
    {
        mmcsd_free_host(host);
    }

    return RT_ERROR;
}

int v3s_sdio_init(void)
{
#ifdef BSP_USING_SDIO0
    mmc_core_init(MMC0);
    if (sdio_device_init(&sdio_drv0, MMC0_BASE_ADDR, dma_buffer0) != RT_EOK)
        return RT_ERROR;
#endif
#ifdef BSP_USING_SDIO2
    mmc_core_init(MMC2);
    if (sdio_device_init(&sdio_drv2, MMC2_BASE_ADDR, dma_buffer2) != RT_EOK)
        return RT_ERROR;
#endif
    return RT_EOK;
}

INIT_DEVICE_EXPORT(v3s_sdio_init);

void v3s_mmcsd_change(void)
{
#ifdef BSP_USING_SDIO0
    if (sdio_drv0.host)
    {
        mmcsd_change(sdio_drv0.host);
    }
#endif
#ifdef BSP_USING_SDIO2
    if (sdio_drv2.host)
    {
        mmcsd_change(sdio_drv2.host);
    }
#endif
}

#endif
